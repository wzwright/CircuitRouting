<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

<div class="container" style="margin:10px;">
	<div class="row" style="margin-top: 10px; margin-bottom: 10px;">
		<button id="placeComp" class="btn btn-default" onclick="compMode()">Place Component</button>
		<span style="margin-left: 50px;">note: press d while a wire is selected to delete</span>
	</div>
	<div class="row">
		<canvas id="canv" width="1200" height="840" style="border:1px solid black;"></canvas>
	</div>
</div>

<script src="./utils.js"></script>
<script>
const mult=20;//grid pixel multiplier
const compSz=4;//component size

class Model{
	constructor(width,height,oldMod){
		this.elements=[];//2d array of what is contained in each point
		this.wires=[];//list of wires represented as list of points
		this.components=[];//list of components, each component marked by top left point
		this.width=width;
		this.height=height;
		
		if(oldMod){
			for(var i=0;i<=width;i++){
				var newCol=[]
				for(var j=0;j<=height;j++)
					newCol.push(new GridItem(oldMod.elements[i][j].type));
				this.elements.push(newCol);
			}

			oldMod.wires.forEach(function(w){
				this.wires.push(w.slice());
			},this);
		}
		else{
			for(var i=0;i<=width;i++){
				var newCol=[]
				for(var j=0;j<=height;j++)
					newCol.push(new GridItem());
				this.elements.push(newCol);
			}
		}
	}

	evaluate(){ //objective function for simulated annealing
		//current: add up length of wire, 2*#intersections, and corners
		//maybe add in bounding box and bus preference later
		var length=0;
		var intersections=0;
		var corners=0;

		for(var i=0;i<=this.width;i++){
			for(var j=0;j<=this.height;j++){
				if(!Types.isWire(this.elements[i][j].type))
					continue;
				length++;
				switch(this.elements[i][j].type){
					case Types.corner:
						corners++;
						break;
					case Types.cross:
						length++;
						intersections++;
						break;
				}
			}
		}

		return length+2*intersections+corners;
	}

	open(x,y,dir){
		if(x<0||y<0||x>this.width||y>this.height)
			return false;
		var typ=this.elements[x][y].type;
		if(dir===undefined){
			return typ===null;
		}
		else if(dir=='h'){
			return typ===null||typ===Types.vert;
		}
		else{ //dir=='v'
			return typ===null||typ===Types.horiz;
		}		
	}
	wirable(x,y){
		return this.elements[x][y].type===Types.edge;
	}	
	component(x,y){
		//check if component isn't overlapping with anything
		if(x+compSz>this.width||y+compSz>this.height)
			return false;
		for(var i=0;i<=compSz;i++){
			for(var j=0;j<=compSz;j++){
				if(this.elements[x+i][y+j].type!==null)
					return false;
			}
		}

		//place component
		this.components.push([x,y])
		for(var i=0;i<=compSz;i++){
			for(var j=0;j<=compSz;j++){
				if(i==0||j==0||i==compSz||j==compSz)
					this.elements[x+i][y+j]=new GridItem("edge");
				else
					this.elements[x+i][y+j]=new GridItem("body");
			}
		}
		return true;
	}
	wire(w){
		var fst=w[0];
		var lst=w[w.length-1];
		var id=this.wires.length;
		this.elements[fst[0]][fst[1]].type=Types.wiredEdge;
		this.elements[fst[0]][fst[1]].wireId=id;
		this.elements[lst[0]][lst[1]].type=Types.wiredEdge;
		this.elements[lst[0]][lst[1]].wireId=id;
		for(var i=1;i<w.length-1;i++){
			var xPrev=w[i-1][0], yPrev=w[i-1][1], xNext=w[i+1][0], yNext=w[i+1][1];			
			var resType=null;
			var prevEmpty=this.elements[w[i][0]][w[i][1]].type===null;
			if(yPrev==yNext)
				resType=prevEmpty?Types.horiz:Types.cross;
			else if(xPrev==xNext)
				resType=prevEmpty?Types.vert:Types.cross;
			else
				resType=Types.corner;
			this.elements[w[i][0]][w[i][1]].type=resType;
			if(resType!==Types.cross)
				this.elements[w[i][0]][w[i][1]].wireId=id;
			else
				this.elements[w[i][0]][w[i][1]].w2=id;
		}
		this.wires.push(w);
	}
	removeWire(index){
		var w=this.wires[index];
		this.elements[w[0][0]][w[0][1]].type=Types.edge;
		this.elements[w[w.length-1][0]][w[w.length-1][1]].type=Types.edge;
		for(var i=1;i<w.length-1;i++){
			var cur=this.elements[w[i][0]][w[i][1]];
			if(cur.type!==Types.cross)
				cur.type=null;			
			else{
				if(w[i-1][0]==w[i+1][0])
					cur.type=Types.horiz;
				else
					cur.type=Types.vert;
				if(cur.wireId==index)
					cur.wireId=cur.w2;
			}
		}
		this.wires.splice(canv.selectedWire,1); //remove
	}
	route(xStart,yStart,xGoal,yGoal){ //A* routing
		var start=[xStart,yStart]
		var goal=[xGoal,yGoal]
		function h(x,y){ //Manhattan distance heuristic
			return Math.abs(x-xGoal)+Math.abs(y-yGoal);
		}
		function openNeighbors(x,y,goal){
			var res=[];
			if(mod.open(x+1,y,'h')||pointEq([x+1,y],goal)){res.push([x+1,y]);}
			if(mod.open(x-1,y,'h')||pointEq([x-1,y],goal)){res.push([x-1,y]);}
			if(mod.open(x,y+1,'v')||pointEq([x,y+1],goal)){res.push([x,y+1]);}
			if(mod.open(x,y-1,'v')||pointEq([x,y-1],goal)){res.push([x,y-1]);}			
			return res;
		}

		var predecessors=Array();
		var startNode=new Node(null, start, h(xStart,yStart));
		var q=new TinyQueue([startNode],Node.compare);
		
		while(q.length!=0){
			var cur=q.pop();
			if(pointEq(cur.state,goal))
				return getPath(cur);

			openNeighbors(cur.state[0],cur.state[1],goal).forEach(function(neighbor){
				var nX=neighbor[0];
				var nY=neighbor[1];
				if((nX in predecessors)&&(nY in predecessors[nX]))
					return;
				if(!(nX in predecessors))
					predecessors[nX]=new Array();
				predecessors[nX][nY]=[cur.state[0],cur.state[1]];
				q.push(new Node(cur, neighbor, h(nX,nY)));
			});
		}

		function getPath(endNode){
			var res=[];
			var cur=endNode;
			while(cur){
				res.push(cur.state);
				cur=cur.parent;
			}
			res.reverse();
			return res;
		}
	}
}
function GridItem(type){
	this.type=type||null;
}

class View{
	constructor(canvas,gridMult){
		//this.elem=canvas;
		this.gm=gridMult;
		this.left=canvas.offsetLeft;
		this.top=canvas.offsetTop;
		this.ctx=canvas.getContext('2d');
		this.width=canvas.width;
		this.height=canvas.height;
		this.mode=Modes.normal;
		this.wireStart=null;
	}

	redraw(){
		this.ctx.clearRect(0,0,this.width,this.height);
		this.grid();
		mod.components.forEach(function(corner){
			var x=corner[0];
			var y=corner[1];
			this.component(x,y);
		},this);
		mod.wires.forEach(function(w){
			this.wire(w);
		},this);
	}

	line(x1,y1,x2,y2){		
		this.ctx.beginPath();
		this.ctx.moveTo(x1*this.gm,y1*this.gm);
		this.ctx.lineTo(x2*this.gm,y2*this.gm);
		this.ctx.stroke();
	}
	wire(w){ //list of points on wire
		this.ctx.beginPath();
		var start=w[0];
		this.ctx.moveTo(start[0]*this.gm,start[1]*this.gm)
		for(var i=1;i<w.length;i++){
			this.ctx.lineTo(w[i][0]*this.gm,w[i][1]*this.gm);
		}
		this.ctx.stroke();
	}
	point(x,y){
		this.ctx.beginPath();
		this.ctx.arc(x*this.gm,y*this.gm,this.gm/4,0,2*Math.PI);
		this.ctx.fill();
	}
	component(x,y){
		this.ctx.strokeStyle="#555";
		this.wire([[x,y],[x+compSz,y],[x+compSz,y+compSz],[x,y+compSz],[x,y]]);
		this.ctx.strokeStyle="#000";
	}
	grid(){
		this.ctx.beginPath();
		this.ctx.strokeStyle="#DDD";
		for(var i=1;i<this.height/this.gm;i++)
			this.line(0,i,this.width,i);
		for(var i=1;i<this.width/this.gm;i++)
			this.line(i,0,i,this.height);		
		this.ctx.stroke();		
		this.ctx.strokeStyle="#000";
	}

	chMode(m,opt){
		this.mode=m;
		this.redraw();
		document.getElementById("placeComp").className="btn btn-default";
		switch(m){
			case Modes.wiring:
				canv.ctx.fillStyle="#A00";
				canv.point(opt[0],opt[1]);
				break;
			case Modes.wire:
				canv.ctx.strokeStyle="#0C0";
				canv.wire(mod.wires[opt]);
				canv.selectedWire=opt;
				break;
			case Modes.component:
				document.getElementById("placeComp").className="btn btn-success";
				break;			
		}

	}
}

function canvClick(event){
	var x=Math.round((event.pageX-canv.left)/mult);
	var y=Math.round((event.pageY-canv.top)/mult);
	switch(canv.mode){
		case Modes.wire:
		case Modes.normal:
			if(mod.wirable(x,y)){
				canv.wireStart=[x,y]
				canv.chMode(Modes.wiring,[x,y]);
			}
			else if(Types.isWire(mod.elements[x][y].type)||mod.elements[x][y].type===Types.wiredEdge){
				var selected=null;
				if((mod.elements[x][y].type===Types.cross)&&Math.random()<0.5)
					selected=mod.elements[x][y].w2;				
				else
					selected=mod.elements[x][y].wireId;
				canv.chMode(Modes.wire,selected);
			}
			break;
		case Modes.wiring:
			if((canv.wireStart[0]!=x||canv.wireStart[1]!=y)&&mod.wirable(x,y)){ 
				var w=mod.route(x,y,canv.wireStart[0],canv.wireStart[1]);
				if(w===undefined){alert("no route possible");return;}					
				mod.wire(w);
				canv.chMode(Modes.normal);
			}
			break;
		case Modes.component:
			if(mod.component(x,y)){				
				canv.chMode(Modes.normal);
			}
			break;
	}
}

function compMode(){
	if(canv.mode==Modes.component)
		canv.chMode(Modes.normal);
	else
		canv.chMode(Modes.component);
}

function handleKeys(e){
	switch(e.keyCode){
		case 27: //esc
			canv.chMode(Modes.normal);
			break;
		case 68: //d
			if(canv.mode===Modes.wire){
				mod.removeWire(canv.selectedWire);
				canv.chMode(Modes.normal);
			}
	}
}

function anneal(steps){
	//known issues:
	//wire start points jump onto each other
	//wire sometimes doubles back on itself
	//not that efficient, tends to give bad routings	

	var s=new Model(mod.width,mod.height,mod);
	var energy=s.evaluate();
	//var best=new Model(mod.width,mod.height,mod);
	//var bestEnergy=val;

	var temp=1;
	for(var i=0;i<steps;i++){
		temp=1-i/steps;
		var next=neighbor();
		if(next===undefined)
			continue;
		var eNew=next.evaluate();
		if(p(energy,eNew)>=Math.random()){
			s=next;
			energy=eNew;
		}
	}

	mod.elements=s.elements;
	mod.wires=s.wires;

	canv.redraw();
	
	function neighbor(){
		var newMod=new Model(s.width,s.height,s);
		var wireNumber=uniformRand(mod.wires.length);
		var wire=mod.wires[wireNumber];
		newMod.removeWire(wireNumber);
		var startIndex=uniformRand(wire.length-3)+1; //subtract 3 because we don't want to pick connection points (first and last) or the very last, since length would be forced to be 0
		var rerouteLength=uniformRand(wire.length-startIndex-2)+1;
		var startX=wire[startIndex][0];
		var startY=wire[startIndex][1];
		var endX=wire[startIndex+rerouteLength][0];
		var endY=wire[startIndex+rerouteLength][1];

		var mid=wire[startIndex+Math.floor(rerouteLength/2)];		
		var maxDistance=temp*50; //adjust the constant
		var randX=Math.round(mid[0]+binomRand(maxDistance,0.5)-maxDistance/2);
		var randY=Math.round(mid[1]+binomRand(maxDistance,0.5)-maxDistance/2);

		if(randX<0||randX>mod.width||randY<0||randY>mod.width)
			return;
		var goalType=mod.elements[randX][randY].type
		if(goalType!==null)//ignoring the possibility of the goal being at a crossing
			return;
		
		var firstHalf=newMod.route(startX,startY,randX,randY);
		var secondHalf=newMod.route(randX,randY,endX,endY);

		if(firstHalf===undefined||secondHalf===undefined)
			return;

		var newWire=wire.slice(0,startIndex); //include part before adjustment
		for(var k=0;k<firstHalf.length&&k<secondHalf.length;k++){ //removing loops
			if(!pointEq(firstHalf[firstHalf.length-k-1],secondHalf[k])){				
				break;
			}
		}		
		for(var i=0;i<firstHalf.length-k+1;i++)
			newWire.push(firstHalf[i]);
		for(var i=k;i<secondHalf.length;i++)
			newWire.push(secondHalf[i]);
		for(var i=startIndex+rerouteLength+1;i<wire.length;i++) //include part after adjustment
			newWire.push(wire[i]);

		newMod.wire(newWire);
		return newMod;
	}
	function p(eOld,eNew){
		if(eNew<eOld)
			return 1;
		return Math.exp(eOld-eNew)*5*temp //scaled to encourage wilder moves in the beginning
	}
}

var mod=new Model(1200/mult, 840/mult); //make sure this is an integer
var canv=new View(document.getElementById('canv'),mult);
document.getElementById('canv').onclick=canvClick;
document.onkeydown=handleKeys;
canv.grid();
</script>